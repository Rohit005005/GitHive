# 🚀 GitHive: A Codebase Question Answering and Repository Analysis Tool

**GitHive** is a powerful application built using the **T3 Stack**, designed to help developers understand and interact with their code repositories more effectively.  
It leverages the power of **Large Language Models (LLMs)** and **vector databases** to provide insightful answers to code-related questions and offer comprehensive repository analysis.

---

## 📌 Workflow Overview

The core functionality revolves around answering questions about a connected GitHub repository.

### **1️⃣ Project Setup**
- User connects a GitHub repository to GitHive.
- The application verifies that the repository is valid.
- Optionally checks if the repository is private using the **GitHub API**.

### **2️⃣ Repository Indexing**
- Uses **@langchain/community** to load the repository's codebase.
- Generates **embeddings** and **summaries** for each file using an **LLM** (likely Google Gemini).
- Stores embeddings, summaries, and source code in a **Prisma database**.
- Handles large repositories efficiently with **concurrency**.

### **3️⃣ Question Answering**
- User asks a question about the codebase via a friendly UI.
- The question is converted into an **embedding** using the same LLM.

### **4️⃣ Context Retrieval**
- The **vector database** searches for relevant code snippets using cosine similarity.
- Retrieves the most relevant files based on the query.

### **5️⃣ AI-Powered Response Generation**
- Relevant code snippets + user’s question are provided as context to the LLM.
- The LLM generates a **detailed, Markdown-formatted answer**, including code snippets.
- The response is **streamed** for an interactive experience.

### **6️⃣ Answer Saving**
- Users can save their Q&A for future reference.
- Likely implemented via backend API calls.

### **7️⃣ Repository Summarization**
- Feeds all indexed code summaries to the LLM.
- Generates a **comprehensive overview** of the project’s purpose and structure.

### **8️⃣ Repository Structure Generation**
- Creates a **visual representation** of the repository file structure.
- Uses LLM inference on file names and directories.

### **9️⃣ Commit Log Analysis**
- Shows recent commits with their summaries.
- Commit messages fetched from the **GitHub API**.
- Summaries generated by the LLM based on code changes.

---

## 🛠️ Technologies Used

| Layer       | Technologies |
|-------------|--------------|
| **Frontend** | React, Next.js, Tailwind CSS, Radix UI, Lucide-React, MDEditor |
| **Backend** | Next.js API Routes, tRPC, Prisma |
| **Database** | Prisma (likely PostgreSQL) |
| **LLM** | Google Gemini |
| **Embeddings** | Custom function using Google Gemini's embedding capabilities |
| **Vector Database** | Custom implementation in Prisma |
| **GitHub API** | Octokit |
| **Code Loading** | @langchain/community |
| **State Management** | React built-in state & possibly react-query |

---

## 📚 Detailed Technology Explanations

- **Next.js** – React framework for server-rendered & static websites; used for frontend & backend (API routes).
- **tRPC** – End-to-end type-safe communication between frontend & backend.
- **Prisma** – Type-safe ORM for database interactions.
- **Tailwind CSS** – Utility-first CSS framework for rapid UI development.
- **React** – JavaScript library for building user interfaces.
- **Google Gemini** – Large Language Model used for Q&A, summarization, and embeddings.
- **@langchain/community** – Library for interacting with LLMs & data sources (loads GitHub repos).
- **Octokit** – GitHub API client for data fetching.
- **Lucide-React** – Icon library for clean, scalable icons.
- **Radix UI** – Accessible, headless UI components.

---

## 📷 Features at a Glance
- 🔍 **AI-Powered Q&A** for any GitHub repository.
- 📄 **Repository Summarization** in one click.
- 🗂️ **Visual File Structure** generation.
- 📜 **Commit Log Analysis** with AI summaries.
- 💾 **Persistent Q&A storage** for future reference.

---

## 🖼️ Example Workflow

1. **Connect Repo** → Verify & index repository.
2. **Ask a Question** → Convert to embeddings.
3. **Retrieve Context** → Search vector DB.
4. **Generate Response** → AI streams the answer.
5. **Save Answer** → For later reference.

---

## 💡 Author
**Rohit** – [LinkedIn](https://www.linkedin.com/in/rohit-dev005/) | [Portfolio](https://portfolio.rohit005.site/) | [Email](rohitdev005005@gmail.com)

